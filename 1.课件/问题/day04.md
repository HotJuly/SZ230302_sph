# 1.v-if和v-show的区别

```
相同点:
	1.他们都可以控制某个组件或者节点的显示隐藏
	2.使用格式都相同
		v-show="true"
		v-if="true"
	
不同点:
	1.他们的原理不同
		v-if是js层面的隐藏,也就是说在解析/更新组件的时候,遇到v-if="false"的节点,
			直接跳过该节点的解析,不挂载该节点,如果该节点已经挂载了,就会卸载他
			
		v-show是css层面的隐藏,也就是说在解析组件的时候,遇到v-show="false"的节点,
			该节点不会被卸载,依旧存活,只是会使用display:none的样式,隐藏该节点的显示
			
			
	扩展面试题:
		v-if和v-show,在项目首次渲染的过程中,v-if的性能更高
			在组件显示状态频繁切换的时候,v-show的性能更高
				原因:在频繁切换的过程中,v-if每次都会卸载组件,所以每次都会重新挂载
						而v-show,只是css样式的隐藏,不会卸载组件,所以他不需要重新挂载,只会挂载一次
```

# 2.路由传参方法一共有几种?

```
一共是三种
1.query
	语法:'/home?username=xiaoming&age=18'
	他是URL传参的一员
	使用场景:
		一般在传递多组数据的时候选择使用
	获取数据的方法:
		通过this.$route.query即可获取到query对象
		
2.params
	语法:'/home/1'
	他是URL传参的一员
	他需要特殊的语法配合:
		-需要在声明路由地址path的时候,书写占位符
			path:"/home/:id"
	使用场景:
		一般在传递1组数据的时候选择使用
	获取数据的方法:
		通过this.$route.params即可获取到params对象
		
3.meta
	它不属于URL传参的一员
	想要使用该方法进行传递数据
		需要在声明路由对象的时候,在与path同级的地方,添加meta属性,内部写上需要传递的数据
	获取数据的方法:
		通过this.$route.meta即可获取到meta对象
	使用场景:
		特点:该方法传递数据非常麻烦,而且不灵活
			无法根据当前的代码运行情况来发生变化
		用于控制一些固定结构的变化
	
```

# 3.本项目中,点击三级分类列表,为什么选择使用路由传参来传递数据?

```javascript
1.props
	该方法适用于
		1.父向子传参
		2.子向父传参
	该写法是否可用?
		可以用,但是不方便
	使用流程:
		1.App组件通过标签属性,将接收数据的函数,传给TypeNav
		2.TypeNav通过声明props,接收App组件传下来的函数
		3.TypeNav在用户点击分类的时候,调用流程2中接收的函数,将数据作为实参传入该函数
		4.App组件接收到数据之后,将数据存入自己的data中
		5.App组件将接收到的分类数据,通过标签属性的形式,传给router-view组件
			router-view组件最终将数据传给Search组件
			
2.provide/inject
	该方法适用于
		祖孙组件之间通讯
	该写法是否可用?
		可以用,但是不方便
	使用流程:
		1.App组件在自己的配置对象中,添加provide函数,并返回一个对象
		2.TypeNav组件,在自己的配置对象中,书写inject数组,接收App组件暴露的provide数据
		3.TypeNav组件,通过接收到的provide数据,将数据存入内部,此时App组件就能获得数据
		4.Search组件,在自己的配置对象中,书写inject数组,用于接收App收集到的数据
		
3.自定义事件
	该方法适用于
		父子组件之间通讯
		主要是父组件用于接收子组件的数据
	该写法是否可用?
		可以用,但是不方便,还需要配合props才能实现
	使用流程:
		1.App组件通过TypeNav组件标签,给TypeNav组件绑定自定义事件,并向传入用于接收数据的回调函数
		2.TypeNav在用户点击分类的时候,调用流程1中绑定的自定义时间,将数据作为实参传入该函数
		3.App组件接收到数据之后,将数据存入自己的data中
		4.App组件将接收到的分类数据,通过标签属性的形式,传给router-view组件
			router-view组件最终将数据传给Search组件
			
4.全局事件总线
	该方法适用于满足一下条件的任何组件之间
		1.订阅方和发布方必须同时存在
		2.订阅操作必须在发布之前
	该写法是否可用?
		不可以
		原因:因为当前TypeNav组件是全局组件,从项目开始运行的时候就会一直存活
			但是Search组件是一个路由组件,很有可能当前路径不是/search,导致他没有挂载
			
5.插槽
	该方法适用于父子组件之间
	该写法是否可用?
		不可以
		原因:该方法主要是用于父组件给子组件传递一段页面结构的,本次传递的只是一些字符串和数字之类的数据
		
6.VueRouter路由传参
	该方法适用于满足以下条件的任何组件之间
		1.在每次传递数据的时候,必须具有跳转路由的操作
	
	该写法是否可用?
		可以用
		原因:因为当用户点击三级分类列表的时候,就需要发生路由跳转
		
7.VueX
	该方法适用于所有情况
	该写法是否可用?
		可以用,但是整体流程过于复杂,所以不用
		
	
		
```

## 