# 1.ES6模块化语法

```
1.默认暴露
	暴露语法:export default 123;
	引入:import data from '文件路径';
	
	无论是哪一种暴露语法,实际暴露的都是一个对象
		{
          default:123
		}
		
2.分别暴露
	暴露语法:
		export const a = 666;
		export const b = 666;
		
	引入:
		-import {a} from '文件路径'
		-import * as data from '文件路径'
		
3.统一暴露
	暴露语法:export {
      a:1,
      b:2
	}
	
4.升级版本语法
	export { default as home} from './modules/home';
	等同于:
		import home from './modules/home';
		export const home = home;
```

# 2.computed和watch的区别

```
1.相同点
	1.他们的基础使用方法几乎相同
		都是对象内部嵌套多个方法
		
	2.他们都可以监视某个数据的变化
		当watch监视的数据发生变化的时候,会自动执行回调函数
		当computed监视的数据发生变化的时候,会自动执行回调函数
		
2.不同点
	1.返回值效果不同
		watch的返回值没有作用
		computed的返回值具有作用,可以用于js代码计算或者template模版展示
		
	2.使用场景
		computed
			我现在需要一个数据,可惜我手头没有,不过我可以根据现有的数据计算得到
				那么我就会使用computed
				
				例如:购物车的总价/总数等功能
					我想要购物车中选中商品的总数量,但是我服务器没返回
					不过我们可以通过现在的购物车数组进行计算得到
			
		watch
			当某个数据发生变化的时候,我想要做一些事情(代码)
				那么我就会使用watch
				
				例如:搜索界面的关键字搜索功能
					当用户搜索的关键字发生变化的时候,我们需要请求最新的数据
					
		小总结:watch更注重于过程,computed更注重于结果
	
	3.缓存
		watch不存在缓存这个事情
		computed在第一次使用的时候肯定会执行一次回调函数,计算出最终的结果进行展示
			如果后续再次使用到同一个computed,如果他监视的数据没有发生变化,对应的回调函数就不会再次执行
				会自动复用上一次计算的结果
```

# 3.对首页三级分类列表进行性能优化

```
问题:虽然当前三级分类列表中,使用router-link组件实现了点击分类,自动跳转到search页面的效果
	但是当前写法并不是最优解
	
原因:因为router-link虽然很小,但是它实际上也是一个组件
	每个组件占用的内存空间肯定都远大于一个a标签
	
优化方案:尽量不使用router-link组件,使用编程式导航替代声明式导航
	因为声明式导航的底层实际上用的还是编程式导航
	
	
再次升级:
	问题:此时具有好几百个节点,点击它们之后都可以跳转到search页面,
		他们的功能完全相同,但是需要绑定非常多的事件监听,所以需要优化
		
	优化方案:
		使用事件委托写法中,使用编程式导航来控制路由跳转
```

# 4.事件相关内容复习

```
问题1:请问什么是事件?
回答:在程序运行过程中,发生的事情或者触发的操作

问题2:事件由几部分组成
回答:
	1.事件名
	2.事件源
	3.事件处理器(又称为事件监听,事件回调函数)
	
问题3:到目前为止,一共出现过几种事件机制?
回答:
	一共出现过三种
	1.事件捕获机制(网景公司)
	2.事件冒泡机制(微软公司,IE)
	3.标准事件机制(又称为标准事件流)
	
问题4:请问标准事件机制中,分为几个阶段?
回答:
	一共分为三个阶段
	1.捕获阶段
		从document元素开始,向内逐层触发同类型事件,直到最内层的目标元素为止
		
	2.目标阶段
		触发目标元素身上,所有的同类型事件
		
	3.冒泡阶段
		从最内层的目标元素开始,向外逐层触发同类型事件,直到最外层的document元素为止
		
问题5:如何阻止冒泡?
回答:
	event.stopPropagation();
	event.cancelBubble=true;(IE专用)
	
	扩展问题:如何阻止捕获?
		1.event.stopPropagation();
		
问题6:什么是事件委托(事件委派)?
回答:
	把后代元素的事件绑定在祖先元素身上
	事件委托不是浏览器推出的内容,是开发者根据事件机制的特性,研究出来的一种性能优化的写法
	
	原理:利用的是事件冒泡的原理
		当用户点击内部的某个元素的时候,会向外冒泡,触发祖先元素的同类型事件
	
问题7:为什么要使用事件委托?
回答:
	因为他是一种性能优化的写法
	
	在没有事件委托之前,存在的问题:
		1.同时具有多个子节点需要绑定事件
			需要声明多个事件回调函数,会占用过多的内存空间
			
	使用事件委托之后,得到的好处:
		1.减少了事件回调函数的声明
			降低对内存空间的消耗
			
		2.后续新增子节点也可以享受到之前绑定的事件委托
```

